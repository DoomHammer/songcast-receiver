# Features

- [X] query preset
- [X] either play by URI (both OHZ and OHU/OHM)
- [X] adjust latency correctly
- [X] detect samplerate/format changes and re-open pulseaudio stream appropiately
- [X] finish preset parsing
- [X] OHU forwarding
- [X] handle out of order packets (epoll might help). Use a heap to store frames when previous frames are missing.
- [X] implement resend request
- [X] build code for managing missed frames. sorted list of integers?
- [X] port to async API
- [X] PA_STREAM_ADJUST_LATENCY
- [ ] clean up play_data...
- [ ] introduce stopped/running state. buffer underruns and drains change state to stopped.
- [ ] handle drains and restarts. save receive timestamp for each frame? which timestamp do we use
- [ ] clean shutdown on ctrl-c, send leave message
- [ ] init/destroy for player.c (also to handle null uri)
- [ ] if ohz: continually listen for matching zone uri messages and switch if changed
- [ ] actually close sockets! (ohz)
- [ ] handle OHM null URL. could be tested with rebooted DSM. it should send null URL first, then transition to real URI later
- [ ] synchronize playback by tweaking the samplerate a little (less then 0.1%)
- [ ] send join until track and metatext is received. adhere to flow diagram
- [ ] check whether destination multicast group matches
- [ ] determine how much of the buffer we control and how much is up to pulseaudio (for resents)
- [ ] can we use linux network timestamps?
- [ ] display codec name
- [ ] display track and metadata
- [ ] set pulseaudio input name to something meaningful
- [ ] create new stream with different sample spec in advance by scanning for changes in buffer?
- [ ] tolerate some amount of out-of-order frames? i.e. wait a few frames before sending resend requests?
- [ ] ohm send event could share code with ohm_send_resend_request
- [ ] read complete source, read all comments, cleanup
- [ ] CHECK_DEAD_GOTO aus simple.c Ã¼bernehmen
- [ ] if buffer runs down to 20ms, fade off?
- [ ] fade in once buffer is 100% filled again

# Buffer underrun handling

Always keep the last 20ms of continuous audio in a separate buffer.
If a buffer underrun approaches, calculate fadeout for this 20ms sample
and rewrite the audio buffer.

After an underrun, reset the prebuf to 100% and start filling the buffer
once it can be fully filled again from the heap. Render 20ms fade-in in this case.

Or maybe this gets to complicated using pulseaudio?

# Restart timestamping

Which timestamp do we use? Do we save each receive timestamp? Do we prefill the cache
if the stream is not yet running? So we can use the same code path for restarts and first
starts?
